# .github/workflows/eoepca-aqbb-notebooks-testing.yml

on: [push]

jobs:
  init:
    name: Update access token
    runs-on: ubuntu-latest
    # https://docs.github.com/en/actions/tutorials/authenticate-with-github_token#modifying-the-permissions-for-the-github_token
    #permissions:
    #  contents: read
    #  # Required to update secrets => No, there is no such "secrets" key 
    #  secrets: write
    outputs:
      access_token: ${{ steps.get_access_token.outputs.access_token }}
    steps:
      - name: Obtain an access token
        id: get_access_token
        env:
          USERNAME: ${{ vars.EOEPCA_APPLICATION_QUALITY_USERNAME }}
          PASSWORD: ${{ secrets.EOEPCA_APPLICATION_QUALITY_PASSWORD }}
          API_URL: ${{ vars.EOEPCA_APPLICATION_QUALITY_API }}
        run: |
          # This script obtains a JWT access token using the user credentials
          echo "User name: $USERNAME"
          echo "API URL: $API_URL"
          
          # Retrieve an access token
          RES_JSON=`curl --json "{ \"username\": \"$USERNAME\", \"password\": \"$PASSWORD\" }" $API_URL/token/`
          ACCESS_TOKEN=`echo $RES_JSON | jq -r '.access'`
          if [ "$ACCESS_TOKEN" = "null" ]; then
            echo "Could not obtain an access token: $RES_JSON"
            exit 1
          fi
          echo "::add-mask::$ACCESS_TOKEN"
          echo "access_token=$ACCESS_TOKEN" >> $GITHUB_OUTPUT
      
      - name: Update the access token secret
        id: update_access_token_secret
        # https://github.com/marketplace/actions/set-action-secret
        uses: hmanzur/actions-set-secret@v2.0.0
        with:
          name: EOEPCA_APPLICATION_QUALITY_ACCESS_TOKEN
          value: ${{ steps.get_access_token.outputs.access_token }}
          repository: ${{ github.repository }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Retrieve pipeline details
        id: get_pipeline_details
        env:
          PIPELINE_ID: ${{ vars.EOEPCA_APPLICATION_QUALITY_PIPELINE_ID_NOTEBOOKS_STATIC }}
          API_URL: ${{ vars.EOEPCA_APPLICATION_QUALITY_API }}
        run: |
          # This script retrieves the pipeline definition from the Application Quality service
          echo "Pipeline request URL $API_URL/pipelines/$PIPELINE_ID/"
          RES_JSON=`curl -H "Authorization: Bearer ${{ steps.get_access_token.outputs.access_token }}" $API_URL/pipelines/$PIPELINE_ID/`
          PIPELINE_ID2=`echo $RES_JSON | jq -r '.id'`
          PIPELINE_NAME=`echo $RES_JSON | jq -r '.name'`
          echo "Pipeline ID: $PIPELINE_ID2"
          echo "Pipeline name: $PIPELINE_NAME"
          if [ "$PIPELINE_NAME" = "null" ]; then
            echo "Could not obtain pipeline details: $RES_JSON"
            exit 2
          fi

  notebooks-static-tests:
    name: Notebooks static tests
    needs: init
    runs-on: ubuntu-latest
    steps:
      - name: Trigger pipeline execution
        id: execute_pipeline
        env:
          PIPELINE_ID: ${{ vars.EOEPCA_APPLICATION_QUALITY_PIPELINE_ID_NOTEBOOKS_STATIC }}
          API_URL: ${{ vars.EOEPCA_APPLICATION_QUALITY_API }}
          ACCESS_TOKEN: ${{ secrets.EOEPCA_APPLICATION_QUALITY_ACCESS_TOKEN }}
        run: |
          # Prepare the parameters then execute the pipeline
          echo "Pipeline ID: $PIPELINE_ID"
          echo "API URL: $API_URL"

          REPO_URL="${{ github.server_url}}/${{ github.repository }}"
          REPO_BRANCH="${{ github.head_ref || github.ref_name }}"
          echo "Repo URL: $REPO_URL"
          echo "Repo Branch: $REPO_BRANCH"

          JSON_DATA=$(jq -n \
            --arg repo_url "$REPO_URL" \
            --arg repo_branch "$REPO_BRANCH" \
            '{
              "parameters": {
                "clone_subworkflow": {
                  "clone": {
                    "repo_url": $repo_url,
                    "repo_branch": $repo_branch
                  }
                }
              }
            }'
          )
          echo "Execution request payload: $JSON_DATA"

          RUNS_URL="$API_URL/pipelines/$PIPELINE_ID/runs/"
          RES_JSON=`curl -H "Authorization: Bearer $ACCESS_TOKEN" --json "$JSON_DATA" $RUNS_URL`
          RUN_ID=`echo $RES_JSON | jq -r '.id'`
          START_TIME=`echo $RES_JSON | jq -r '.start_time'`
          echo "Pipeline run ID: $RUN_ID"
          echo "Start time: $START_TIME"
          if [ "$RUN_ID" = "null" ]; then
            echo "Could not execute the pipeline: $RES_JSON"
            exit 3
          fi

  notebooks-execution-tests:
    name: Notebooks execution tests
    needs: init
    runs-on: ubuntu-latest
    steps:
      - name: Trigger pipeline execution
        id: execute_pipeline
        env:
          PIPELINE_ID: ${{ vars.EOEPCA_APPLICATION_QUALITY_PIPELINE_ID_NOTEBOOKS_EXEC }}
          API_URL: ${{ vars.EOEPCA_APPLICATION_QUALITY_API }}
          ACCESS_TOKEN: ${{ secrets.EOEPCA_APPLICATION_QUALITY_ACCESS_TOKEN }}
        run: |
          # Prepare the parameters then execute the pipeline
          echo "Pipeline ID: $PIPELINE_ID"
          echo "API URL: $API_URL"

          REPO_URL="${{ github.server_url}}/${{ github.repository }}"
          REPO_BRANCH="${{ github.head_ref || github.ref_name }}"
          echo "Repo URL: $REPO_URL"
          echo "Repo Branch: $REPO_BRANCH"

          JSON_DATA=$(jq -n \
            --arg repo_url "$REPO_URL" \
            --arg repo_branch "$REPO_BRANCH" \
            '{
              "parameters": {
                "clone_subworkflow": {
                  "clone": {
                    "repo_url": $repo_url,
                    "repo_branch": $repo_branch
                  }
                }
              }
            }'
          )
          echo "Execution request payload: $JSON_DATA"

          RUNS_URL="$API_URL/pipelines/$PIPELINE_ID/runs/"
          RES_JSON=`curl -H "Authorization: Bearer $ACCESS_TOKEN" --json "$JSON_DATA" $RUNS_URL`
          RUN_ID=`echo $RES_JSON | jq -r '.id'`
          START_TIME=`echo $RES_JSON | jq -r '.start_time'`
          echo "Pipeline run ID: $RUN_ID"
          echo "Start time: $START_TIME"
          if [ "$RUN_ID" = "null" ]; then
            echo "Could not execute the pipeline: $RES_JSON"
            exit 3
          fi
